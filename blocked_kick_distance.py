# -*- coding: utf-8 -*-
"""Blocked Kick Distance.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1V-mcIK3AAaGZ0sPPfiMi1YZa4ZcmU69b
"""

import numpy as np
import pandas as pd
import statsmodels.api as sm
import statsmodels.formula.api as smf
from scipy.stats import norm
import scipy.stats as st

path_merged = "/content/drive/MyDrive/NFL Merged Data/merged_nfl_data_1999_2025_TRIM.csv"
df_pbp = pd.read_csv(path_merged)

# A) Independent FG dataset with RAW outcomes preserved

df_block = df_pbp[
    (df_pbp['play_type'] == 'field_goal') &
    (df_pbp['field_goal_result'].isin(['made', 'missed', 'blocked']))
].copy()

# Preserve raw outcome text
df_block['fg_outcome_raw'] = df_block['field_goal_result'].astype(str).str.lower()
df_block['is_blocked'] = (df_block['fg_outcome_raw'] == 'blocked').astype(int)
df_block['fg_made'] = df_block['fg_outcome_raw'].map({'made': 1, 'missed': 0, 'blocked': 0}).astype(int)

# Numeric safety
df_block['kick_distance'] = pd.to_numeric(df_block['kick_distance'], errors='coerce')
df_block['yardline_100']  = pd.to_numeric(df_block['yardline_100'], errors='coerce')

# Drop rows missing essentials
df_block = df_block.dropna(subset=['kick_distance', 'yardline_100']).copy()


# B) Compute hold depth (7 vs 8), filter to those two values
# distance ≈ LOS + hold_depth + 10  => hold_depth = kick_distance − yardline_100 − 10

df_block['hold_depth'] = (df_block['kick_distance'] - df_block['yardline_100'] - 10).round()
df_block['hold_depth'] = pd.to_numeric(df_block['hold_depth'], errors='coerce').astype('Int64')

print("Hold-depth (pre-filter) counts:")
print(df_block['hold_depth'].value_counts(dropna=False).sort_index())

df_block = df_block[df_block['hold_depth'].isin([7, 8])].copy()
df_block['hold_depth'] = df_block['hold_depth'].astype(int)

print("\nHold-depth (post 7/8 filter) counts:")
print(df_block['hold_depth'].value_counts(dropna=False).sort_index())

print("\nBlocked counts:")
print(df_block['is_blocked'].value_counts(dropna=False))


# C) Descriptives: blocked rate by distance band × hold depth

bins = [0, 20, 29, 34, 39, 49, 99]
labels = ['<20', '20–29', '30–34', '35–39', '40–49', '50+']

df_block['dist_bin'] = pd.cut(df_block['kick_distance'], bins=bins, labels=labels, right=True)

blocked_table = (
    df_block.groupby(['dist_bin', 'hold_depth'])['is_blocked']
            .agg(N='size', blocked_rate='mean')
            .reset_index()
)

print("\nBlocked rate by distance band × hold depth")
print(blocked_table.to_string(index=False))


# D) Model (short kicks): does 8 vs 7 change block odds?
# Use a binomial GLM with clustered SEs by game_id (more stable than Logit sometimes)

short = df_block[df_block['kick_distance'].between(20, 39)].copy()

# Context vars (consistent with your other sections)
short['stadium_open'] = short['roof'].fillna('unknown').eq('open').astype(int)

short['wind_filled'] = pd.to_numeric(short.get('wind'), errors='coerce').fillna(0)  # 0 is reasonable baseline
temp_num = pd.to_numeric(short.get('temp'), errors='coerce')
short['temp_filled'] = temp_num.fillna(temp_num.median())

# Clutch definition consistent with your main logic (<=120 sec or OT)
short['qtr'] = pd.to_numeric(short['qtr'], errors='coerce')
short['game_seconds_remaining'] = pd.to_numeric(short['game_seconds_remaining'], errors='coerce')
short['clutch'] = ((short['game_seconds_remaining'] <= 120) | (short['qtr'] >= 5)).astype(int)

short['hold8'] = (short['hold_depth'] == 8).astype(int)
short['kick_distance_sq'] = short['kick_distance'] ** 2

# If you want year FE, make sure year is numeric
short['year'] = pd.to_numeric(short['year'], errors='coerce')

glm_formula = (
    "is_blocked ~ hold8 + kick_distance + kick_distance_sq"
    " + wind_filled + temp_filled + stadium_open + clutch"
    " + C(year)"
)

# Drop NAs used by model
need = ['is_blocked', 'hold8', 'kick_distance', 'kick_distance_sq', 'wind_filled', 'temp_filled', 'stadium_open', 'clutch', 'year', 'game_id']
short_m = short.dropna(subset=need).copy()

glm = smf.glm(glm_formula, data=short_m, family=sm.families.Binomial()).fit(
    cov_type='cluster',
    cov_kwds={'groups': short_m['game_id']}
)

print("\n=== Clustered Binomial GLM: short kicks (20–39) ===")
print(glm.summary())


# E) OPTIONAL: Matched-cell comparison (7 vs 8) within similar context
# This is stricter; if it returns empty, relax bins.

dfe = df_block.copy()

# build stable context buckets
wind = pd.to_numeric(dfe.get('wind'), errors='coerce').fillna(0)
temp = pd.to_numeric(dfe.get('temp'), errors='coerce')
temp = temp.fillna(temp.median())

dfe['stadium_open'] = dfe['roof'].fillna('unknown').eq('open').astype(int)

wind_key = pd.cut(wind, bins=[-0.1, 5, 10, 99], labels=['0-5', '6-10', '11+']).astype(object).fillna('Unknown')
temp_key = pd.cut(temp, bins=[-50, 40, 60, 80, 200], labels=['<=40', '41-60', '61-80', '>80']).astype(object).fillna('Unknown')

qtr_key = pd.to_numeric(dfe.get('qtr'), errors='coerce').clip(upper=4).fillna(4).astype(int)

score = pd.to_numeric(dfe.get('score_differential'), errors='coerce').fillna(0)
score_key = pd.cut(score, bins=[-60, -7, -3, 3, 7, 60],
                   labels=['<=-7', '-6 to -3', '-2 to 2', '3 to 6', '>=7']).astype(object).fillna('Unknown')

dist_key = pd.to_numeric(dfe['kick_distance'], errors='coerce').round().astype('Int64').astype(str)

# cell id
dfe['cell_id'] = (
    dist_key + '|' +
    dfe['stadium_open'].astype(int).astype(str) + '|' +
    wind_key.astype(str) + '|' +
    temp_key.astype(str) + '|' +
    qtr_key.astype(str) + '|' +
    score_key.astype(str)
)

cell_counts = dfe.groupby(['cell_id', 'hold_depth']).size().unstack(fill_value=0)
cell_counts = cell_counts.reindex(columns=[7, 8], fill_value=0)

eligible_cells = cell_counts[(cell_counts[7] > 0) & (cell_counts[8] > 0)].index
dfe = dfe[dfe['cell_id'].isin(eligible_cells)].copy()

if dfe.empty:
    print("\nMatched-cell step produced 0 rows. Relax bins (wind/temp/score) if you want matches.")
else:
    cell_stats = (dfe
      .groupby(['cell_id', 'hold_depth'])['is_blocked']
      .agg(rate='mean', N='size')
      .reset_index())

    pivot = (cell_stats
      .pivot(index='cell_id', columns='hold_depth', values=['rate', 'N'])
      .reindex(columns=pd.MultiIndex.from_product([['rate', 'N'], [7, 8]]))
      .dropna())

    pivot['diff_8minus7'] = pivot[('rate', 8)] - pivot[('rate', 7)]
    pivot['N_total'] = pivot[('N', 7)].fillna(0) + pivot[('N', 8)].fillna(0)

    avg_unweighted = pivot['diff_8minus7'].mean()
    avg_weighted = (pivot['diff_8minus7'] * pivot['N_total']).sum() / pivot['N_total'].sum()

    tstat, pval = st.ttest_1samp(pivot['diff_8minus7'].dropna().values, 0.0)

    print(f"\n=== Matched-cell results (within-context 8 minus 7) ===")
    print(f"Matched cells: {len(pivot):,}")
    print(f"Mean diff (unweighted): {avg_unweighted:.4f}")
    print(f"Mean diff (weighted by cell size): {avg_weighted:.4f}")
    print(f"t-test across cells: t={tstat:.2f}, p={pval:.3f}")

"""# **Blocked kicks INCLUDING extra points (FG + XP)**"""

if 'df_pbp' not in globals():
    PATH = "/content/drive/MyDrive/NFL Merged Data/merged_nfl_data_1999_2025_TRIM.csv"
    df_pbp = pd.read_csv(PATH, low_memory=False)

# 1) Only kicks (FG + XP)
keep_types = df_pbp['play_type'].astype(str).str.lower().isin(['field_goal', 'extra_point'])
df_kicks = df_pbp.loc[keep_types].copy()

# 2) ONE unified raw outcome text (FG uses field_goal_result, XP uses extra_point_result)
fg_out = df_kicks.get('field_goal_result', pd.Series(index=df_kicks.index, dtype=object))
xp_out = df_kicks.get('extra_point_result', pd.Series(index=df_kicks.index, dtype=object))

df_kicks['raw_outcome'] = np.where(
    df_kicks['play_type'].astype(str).str.lower().eq('extra_point'),
    xp_out,
    fg_out
)
df_kicks['raw_outcome'] = df_kicks['raw_outcome'].astype(str).str.lower()


valid_outcomes = {'made','missed','blocked','good','failed','aborted'}
df_kicks = df_kicks[df_kicks['raw_outcome'].isin(valid_outcomes)].copy()

# 3) Binary flags
df_kicks['is_blocked'] = df_kicks['raw_outcome'].eq('blocked').astype(int)
df_kicks['made_flag']  = df_kicks['raw_outcome'].isin(['made','good']).astype(int)

# 4) Coerce key numeric fields safely
for col in ['yardline_100', 'kick_distance', 'wind', 'temp', 'qtr', 'score_differential', 'game_seconds_remaining', 'year']:
    if col in df_kicks.columns:
        df_kicks[col] = pd.to_numeric(df_kicks[col], errors='coerce')

# Need yardline_100 and kick_distance for hold depth
df_kicks = df_kicks.dropna(subset=['yardline_100', 'kick_distance']).copy()

# 5) Hold depth identity: hold_depth = kick_distance − yardline_100 − 10
df_kicks['hold_depth'] = (df_kicks['kick_distance'] - df_kicks['yardline_100'] - 10).round().astype('Int64')

print("Hold-depth counts (pre 7/8 filter):")
print(df_kicks['hold_depth'].value_counts(dropna=False).sort_index())

# Keep only 7 vs 8
df_kicks = df_kicks[df_kicks['hold_depth'].isin([7, 8])].copy()
df_kicks['hold_depth'] = df_kicks['hold_depth'].astype(int)

print("\nHold-depth counts (post 7/8 filter):")
print(df_kicks['hold_depth'].value_counts().sort_index())

# 6) Convenience fields / controls (consistent with your FG-only section)
df_kicks['kick_type'] = df_kicks['play_type'].astype(str).str.lower().map({'field_goal':'FG', 'extra_point':'XP'})
df_kicks['stadium_open'] = df_kicks['roof'].fillna('unknown').astype(str).str.lower().eq('open').astype(int)

df_kicks['wind_filled'] = pd.to_numeric(df_kicks['wind'], errors='coerce').fillna(0)
df_kicks['temp_filled'] = pd.to_numeric(df_kicks['temp'], errors='coerce')
df_kicks['temp_filled'] = df_kicks['temp_filled'].fillna(df_kicks['temp_filled'].median())

# Clutch definition: last 2 minutes OR overtime-ish (qtr>=5)
df_kicks['qtr'] = pd.to_numeric(df_kicks['qtr'], errors='coerce')
df_kicks['game_seconds_remaining'] = pd.to_numeric(df_kicks['game_seconds_remaining'], errors='coerce')
df_kicks['clutch'] = (
    (df_kicks['game_seconds_remaining'] <= 120) |
    (df_kicks['qtr'] >= 5)
).fillna(False).astype(int)

# Need game_id for clustering in models
if 'game_id' not in df_kicks.columns:
    raise ValueError("Expected 'game_id' column for clustering but it was not found.")

# 7) Descriptives: blocked rate by distance band × hold depth × kick type
bins   = [0, 20, 29, 34, 39, 49, 99]
labels = ['<20', '20–29', '30–34', '35–39', '40–49', '50+']
df_kicks['dist_bin'] = pd.cut(df_kicks['kick_distance'], bins=bins, labels=labels, right=True)

desc = (df_kicks
        .groupby(['kick_type','dist_bin','hold_depth'], observed=True)['is_blocked']
        .agg(N='size', blocked_rate='mean')
        .reset_index())
print("\nBlocked rate by kick type × distance band × hold depth:")
print(desc.to_string(index=False))

# 8) Short-kick clustered model (20–39): pooled FG+XP
short = df_kicks[df_kicks['kick_distance'].between(20, 39)].copy()
short['hold8']  = (short['hold_depth'] == 8).astype(int)
short['is_pat'] = (short['kick_type'] == 'XP').astype(int)

# Drop rows missing essential regressors
short = short.dropna(subset=['year','wind_filled','temp_filled','stadium_open','clutch','game_id']).copy()
short['year'] = short['year'].astype(int)

# Use GLM Binomial (stable; Logit can fail under separation)
formula = (
    "is_blocked ~ hold8 + is_pat + hold8:is_pat "
    "+ kick_distance + I(kick_distance**2) "
    "+ wind_filled + temp_filled + stadium_open + clutch "
    "+ C(year)"
)

print("\n=== Clustered Binomial GLM: short kicks (20–39), FG + XP ===")
glm_res = smf.glm(formula, data=short, family=sm.families.Binomial()).fit(
    cov_type='cluster',
    cov_kwds={'groups': short['game_id']}
)
print(glm_res.summary())

print("\nInterpretation guide:")
print("  hold8        = 8 vs 7 effect for FIELD GOALS (baseline is_pat=0).")
print("  hold8:is_pat = extra 8 vs 7 effect on PATs relative to FGs.")
print("  is_pat       = baseline PAT vs FG difference at hold_depth=7 (net of controls).")

# 9) Matched-cells “same situation” comparison (FG + XP)
df = df_kicks.copy()

# Build coarse context buckets (fill Unknown to avoid NaNs in cell_id)
wind_key = pd.cut(df['wind_filled'], bins=[-0.1, 5, 10, 99], labels=['0-5','6-10','11+']).astype(object).fillna('Unknown')
temp_key = pd.cut(df['temp_filled'], bins=[-50, 40, 60, 80, 200], labels=['<=40','41-60','61-80','>80']).astype(object).fillna('Unknown')

qtr_key = pd.to_numeric(df['qtr'], errors='coerce').clip(upper=4).fillna(4).astype(int)
score_f = pd.to_numeric(df['score_differential'], errors='coerce').fillna(0)
score_key = pd.cut(score_f, bins=[-60,-7,-3,3,7,60],
                   labels=['<=-7','-6 to -3','-2 to 2','3 to 6','>=7']).astype(object).fillna('Unknown')

# Exact rounded distance to avoid distance confounding
dist_key = df['kick_distance'].round().astype('Int64').astype(str)

# Cell id includes kick_type so FG and XP are not forced into the same “exact distance” cells
df['cell_id'] = (
    dist_key + '|' +
    df['stadium_open'].astype(int).astype(str) + '|' +
    wind_key.astype(str) + '|' +
    temp_key.astype(str) + '|' +
    qtr_key.astype(str) + '|' +
    score_key.astype(str) + '|' +
    df['kick_type'].astype(str)
)

cell_counts = df.groupby(['cell_id','hold_depth']).size().unstack(fill_value=0)
cell_counts = cell_counts.reindex(columns=[7,8], fill_value=0)

eligible = cell_counts[(cell_counts[7] > 0) & (cell_counts[8] > 0)].index
dfe = df[df['cell_id'].isin(eligible)].copy()

cell_stats = (dfe.groupby(['cell_id','hold_depth'], observed=True)['is_blocked']
                .agg(rate='mean', N='size')
                .reset_index())

pivot = (cell_stats
         .pivot(index='cell_id', columns='hold_depth', values=['rate','N'])
         .reindex(columns=pd.MultiIndex.from_product([['rate','N'], [7,8]]))
         .dropna())

pivot['diff_8minus7'] = pivot[('rate',8)] - pivot[('rate',7)]
pivot['N_total']      = pivot[('N',7)] + pivot[('N',8)]

avg_unweighted = pivot['diff_8minus7'].mean()
avg_weighted   = (pivot['diff_8minus7'] * pivot['N_total']).sum() / pivot['N_total'].sum()

tstat, pval = st.ttest_1samp(pivot['diff_8minus7'].values, 0.0) if len(pivot) > 1 else (np.nan, np.nan)

print("\n=== Matched-cell results (FG + XP, within-context 8 minus 7) ===")
print(f"Matched cells: {len(pivot):,}")
print(f"Mean diff (unweighted): {avg_unweighted:.4f}")
print(f"Mean diff (weighted by cell size): {avg_weighted:.4f}")
print(f"t-test across cells: t={tstat:.2f}, p={pval:.3f}" if len(pivot) > 1 else "t-test skipped (not enough matched cells)")

"""# **Combined FG + XP (PAT) — pooled model + matched cells + year-by-year tables**"""

if 'df_pbp' not in globals():
    PATH = "/content/drive/MyDrive/NFL Merged Data/merged_nfl_data_1999_2025_TRIM.csv"
    df_pbp = pd.read_csv(PATH, low_memory=False)

# 1) Unified kicks dataset ONCE (FG + XP)
keep_types = df_pbp['play_type'].astype(str).str.lower().isin(['field_goal', 'extra_point'])
df = df_pbp.loc[keep_types].copy()

# Unified outcome text
fg_out = df.get('field_goal_result', pd.Series(index=df.index, dtype=object))
xp_out = df.get('extra_point_result', pd.Series(index=df.index, dtype=object))

df['raw_outcome'] = np.where(
    df['play_type'].astype(str).str.lower().eq('extra_point'),
    xp_out,
    fg_out
)
df['raw_outcome'] = df['raw_outcome'].astype(str).str.lower()

valid_outcomes = {'made', 'missed', 'blocked', 'good', 'failed', 'aborted'}
df = df[df['raw_outcome'].isin(valid_outcomes)].copy()

# Block indicator (strict)
df['is_blocked'] = df['raw_outcome'].eq('blocked').astype(int)

# 2) Coerce numeric columns needed downstream
need_num = ['kick_distance','yardline_100','wind','temp','qtr','score_differential',
            'year','game_seconds_remaining']
for col in need_num:
    if col in df.columns:
        df[col] = pd.to_numeric(df[col], errors='coerce')

# kick_distance + yardline_100 for hold depth
df = df.dropna(subset=['kick_distance','yardline_100']).copy()

# Hold depth
df['hold_depth'] = (df['kick_distance'] - df['yardline_100'] - 10).round().astype('Int64')

print("Hold-depth counts (pre 7/8 filter):")
print(df['hold_depth'].value_counts(dropna=False).sort_index())

#  Only 7 vs 8
df = df[df['hold_depth'].isin([7, 8])].copy()
df['hold_depth'] = df['hold_depth'].astype(int)

print("\nHold-depth counts (post 7/8 filter):")
print(df['hold_depth'].value_counts().sort_index())

# Game_id for clustering
if 'game_id' not in df.columns:
    raise ValueError("Expected 'game_id' column for clustering; not found.")

# 3) Controls
df['stadium_open'] = df['roof'].fillna('unknown').astype(str).str.lower().eq('open').astype(int)

df['wind_filled'] = pd.to_numeric(df['wind'], errors='coerce').fillna(0)
df['temp_filled'] = pd.to_numeric(df['temp'], errors='coerce')
df['temp_filled'] = df['temp_filled'].fillna(df['temp_filled'].median())

df['qtr'] = pd.to_numeric(df['qtr'], errors='coerce')
df['game_seconds_remaining'] = pd.to_numeric(df['game_seconds_remaining'], errors='coerce')
df['clutch'] = (
    (df['game_seconds_remaining'] <= 120) |
    (df['qtr'] >= 5)
).fillna(False).astype(int)

# Year must be int for FE
df = df.dropna(subset=['year','game_id','wind_filled','temp_filled','stadium_open','clutch']).copy()
df['year'] = df['year'].astype(int)

# Flags
df['hold8'] = (df['hold_depth'] == 8).astype(int)
df['is_pat'] = df['play_type'].astype(str).str.lower().eq('extra_point').astype(int)


print("\nCounts by play_type:")
print(df['play_type'].value_counts())
print("\nHold-depth counts by play_type:")
print(df.groupby('play_type')['hold_depth'].value_counts())
print("\nBlocked rates by play_type × hold_depth:")
print(df.groupby(['play_type','hold_depth'])['is_blocked'].mean())


# (1) Pooled model with PAT interaction (cluster by game)

formula = (
    "is_blocked ~ hold8 + is_pat + hold8:is_pat "
    "+ kick_distance + I(kick_distance**2) "
    "+ wind_filled + temp_filled + stadium_open + clutch "
    "+ C(year)"
)

print("\n--- Pooled Blocked Model (FG+XP) with PAT interaction, clustered by game ---")
try:
    pooled = smf.logit(formula, data=df).fit(
        cov_type='cluster',
        cov_kwds={'groups': df['game_id']},
        disp=False
    )
    print(pooled.summary())
except Exception as e:
    print(f"Logit failed ({e}). Falling back to GLM Binomial (clustered).")
    pooled = smf.glm(formula, data=df, family=sm.families.Binomial()).fit(
        cov_type='cluster',
        cov_kwds={'groups': df['game_id']}
    )
    print(pooled.summary())

print("\nInterpretation guide:")
print("  hold8        = 8 vs 7 effect for FIELD GOALS (baseline is_pat=0).")
print("  hold8:is_pat = extra 8 vs 7 effect on PATs relative to FGs.")
print("  is_pat       = baseline PAT vs FG difference at hold_depth=7 (net of controls + year FE).")


# (2) Matched “same-situation” cells
# Cell includes PAT/FG so can compare 7 vs 8 within the SAME kick type.

wind_key = pd.cut(df['wind_filled'], bins=[-0.1, 5, 10, 99], labels=['0-5','6-10','11+']).astype(object).fillna('Unknown')
temp_key = pd.cut(df['temp_filled'], bins=[-50, 40, 60, 80, 200], labels=['<=40','41-60','61-80','>80']).astype(object).fillna('Unknown')
qtr_key  = df['qtr'].clip(upper=4).fillna(4).astype(int)

score_num = pd.to_numeric(df['score_differential'], errors='coerce').fillna(0)
score_key = pd.cut(score_num, bins=[-60,-7,-3,3,7,60],
                   labels=['<=-7','-6 to -3','-2 to 2','3 to 6','>=7']).astype(object).fillna('Unknown')

dist_key = df['kick_distance'].round().astype('Int64').astype(str)

df['cell_id'] = (
    dist_key + '|' +
    df['is_pat'].astype(int).astype(str) + '|' +          # FG and XP separate
    df['stadium_open'].astype(int).astype(str) + '|' +
    wind_key.astype(str) + '|' +
    temp_key.astype(str) + '|' +
    qtr_key.astype(str) + '|' +
    score_key.astype(str)
)

cell_counts = df.groupby(['cell_id','hold_depth']).size().unstack(fill_value=0)
cell_counts = cell_counts.reindex(columns=[7,8], fill_value=0)
eligible_cells = cell_counts[(cell_counts[7] > 0) & (cell_counts[8] > 0)].index
dfe = df[df['cell_id'].isin(eligible_cells)].copy()

print(f"\nMatched cells (both 7 & 8 present): {len(eligible_cells):,}  |  Rows kept: {len(dfe):,}")

cell_stats = (
    dfe.groupby(['cell_id','hold_depth'])['is_blocked']
       .agg(rate='mean', N='size')
       .reset_index()
)

pivot = (
    cell_stats
    .pivot(index='cell_id', columns='hold_depth', values=['rate','N'])
    .reindex(columns=pd.MultiIndex.from_product([['rate','N'], [7,8]]))
    .dropna()
)

pivot['diff_8minus7'] = pivot[('rate',8)] - pivot[('rate',7)]
pivot['N_total']      = pivot[('N',7)].fillna(0) + pivot[('N',8)].fillna(0)

avg_unweighted = pivot['diff_8minus7'].mean()
avg_weighted   = (pivot['diff_8minus7'] * pivot['N_total']).sum() / pivot['N_total'].sum()

print("\n--- Matched 'same-situation' comparison ---")
print(f"Matched cells: {len(pivot):,}")
print(f"Mean within-cell diff (8 − 7): {avg_unweighted:.4f} (unweighted)")
print(f"Weighted by cell size: {avg_weighted:.4f}")

if len(pivot) > 1:
    tstat, pval = st.ttest_1samp(pivot['diff_8minus7'].values, 0.0)
    print(f"Paired t-test across cells: t={tstat:.2f}, p={pval:.3f}")
else:
    print("Paired t-test skipped (not enough matched cells).")


# (3) Year-by-year tables (no controls): exact distance matching

df['dist_int'] = df['kick_distance'].round().astype('Int64')

same_distance = (
    df.groupby(['year','dist_int','hold_depth'])['is_blocked']
      .agg(rate='mean', N='size')
      .reset_index()
)

same_distance_pivot = (
    same_distance
      .pivot(index=['year','dist_int'], columns='hold_depth', values=['rate','N'])
      .reindex(columns=pd.MultiIndex.from_product([['rate','N'], [7,8]]))
      .reset_index()
)

same_distance_pivot['diff_8minus7'] = same_distance_pivot[('rate',8)] - same_distance_pivot[('rate',7)]

print("\n=== SAME DISTANCE (exact, year-by-year) ===")
print(same_distance_pivot.head(20))

# Stability filter
minN = 10
mask = (same_distance_pivot[('N',7)].fillna(0) >= minN) & (same_distance_pivot[('N',8)].fillna(0) >= minN)
stable_same_dist = same_distance_pivot[mask].copy()
print(f"\nSame-distance rows with N7>= {minN} and N8>= {minN}: {len(stable_same_dist)}")

# (4) Year-by-year tables: 5-yard LOS bins

edges = list(range(0, 55, 5))  # 0..50
labels = [f"{edges[i]}–{edges[i+1]-1}" for i in range(len(edges)-1)]
df['yl5'] = pd.cut(df['yardline_100'].clip(lower=0, upper=50), bins=edges, labels=labels, right=False)

binned = (
    df.groupby(['year','yl5','hold_depth'])['is_blocked']
      .agg(rate='mean', N='size')
      .reset_index()
)

binned_pivot = (
    binned
      .pivot(index=['year','yl5'], columns='hold_depth', values=['rate','N'])
      .reindex(columns=pd.MultiIndex.from_product([['rate','N'], [7,8]]))
      .reset_index()
)

binned_pivot['diff_8minus7'] = binned_pivot[('rate',8)] - binned_pivot[('rate',7)]

print("\n=== 5-YARD LOS BINS (year-by-year) ===")
print(binned_pivot.head(20))

mask2 = (binned_pivot[('N',7)].fillna(0) >= minN) & (binned_pivot[('N',8)].fillna(0) >= minN)
stable_binned = binned_pivot[mask2].copy()
print(f"\nBinned rows with N7>= {minN} and N8>= {minN}: {len(stable_binned)}")


# (5) Per-season overall (no bins): block rates by hold depth

per_season = (
    df.groupby(['year','hold_depth'])['is_blocked']
      .agg(rate='mean', N='size')
      .reset_index()
      .pivot(index='year', columns='hold_depth', values=['rate','N'])
      .reindex(columns=pd.MultiIndex.from_product([['rate','N'], [7,8]]))
)

per_season['diff_8minus7'] = per_season[('rate',8)] - per_season[('rate',7)]

print("\n=== Per-season overall block rates by hold depth (FG+XP mixed) ===")
print(per_season.tail(10))

"""# **FG + XP "WITHOUT CONTROLS" - Distance-only matched comparison**"""

if 'df_pbp' not in globals():
    PATH = "/content/drive/MyDrive/NFL Merged Data/merged_nfl_data_1999_2025_TRIM.csv"
    df_pbp = pd.read_csv(PATH, low_memory=False)

# 1) Unified kicks frame (FG + XP)
keep = df_pbp['play_type'].astype(str).str.lower().isin(['field_goal', 'extra_point'])
df = df_pbp.loc[keep].copy()

fg_out = df.get('field_goal_result', pd.Series(index=df.index, dtype=object)).astype(str).str.lower()
xp_out = df.get('extra_point_result', pd.Series(index=df.index, dtype=object)).astype(str).str.lower()

df['outcome_raw'] = np.where(
    df['play_type'].astype(str).str.lower().eq('extra_point'),
    xp_out,
    fg_out
)

valid = {'made','missed','blocked','good','failed','aborted'}
df = df[df['outcome_raw'].isin(valid)].copy()

# Blocked indicator
df['is_blocked'] = df['outcome_raw'].eq('blocked').astype(int)

# 2) Hold depth identity: hold = kick_distance − yardline_100 − 10
df['kick_distance'] = pd.to_numeric(df['kick_distance'], errors='coerce')
df['yardline_100']  = pd.to_numeric(df['yardline_100'],  errors='coerce')
df = df.dropna(subset=['kick_distance','yardline_100']).copy()

df['hold_depth'] = (df['kick_distance'] - df['yardline_100'] - 10).round().astype('Int64')

print("Hold-depth (pre-filter):")
print(df['hold_depth'].value_counts(dropna=False).sort_index())

# Keep only 7 vs 8
df = df[df['hold_depth'].isin([7, 8])].copy()
df['hold_depth'] = df['hold_depth'].astype(int)

print("\nHold-depth (post 7/8 filter):")
print(df['hold_depth'].value_counts().sort_index())

# 3) Distance-only matching key (exact rounded distance)
df['dist_key'] = df['kick_distance'].round().astype('Int64')

# Distances where BOTH depths appear
depth_counts = df.groupby(['dist_key','hold_depth']).size().unstack(fill_value=0)
depth_counts = depth_counts.reindex(columns=[7, 8], fill_value=0)

eligible_dist = depth_counts[(depth_counts[7] > 0) & (depth_counts[8] > 0)].index
print("\nEligible exact distances (both depths present):", len(eligible_dist))

dfe = df[df['dist_key'].isin(eligible_dist)].copy()
if dfe.empty:
    raise RuntimeError("No distances with both 7 & 8. Check data or rounding/hold_depth logic.")

# 4) Within-distance blocked rates by depth + differences
dist_stats = (
    dfe.groupby(['dist_key','hold_depth'])['is_blocked']
       .agg(rate='mean', N='size')
       .reset_index()
)

pivot = (
    dist_stats
    .pivot(index='dist_key', columns='hold_depth', values=['rate','N'])
    .reindex(columns=pd.MultiIndex.from_product([['rate','N'], [7,8]]))
    .dropna()
)

pivot['diff_8minus7'] = pivot[('rate',8)] - pivot[('rate',7)]
pivot['N_total']      = pivot[('N',7)] + pivot[('N',8)]

# 5) Summaries + t-test
avg_unweighted = pivot['diff_8minus7'].mean()
avg_weighted   = (pivot['diff_8minus7'] * pivot['N_total']).sum() / pivot['N_total'].sum()

print(f"\nMatched distances: {len(pivot):,}")
print(f"Mean within-distance diff (8 − 7) in block rate: {avg_unweighted:.4f} (unweighted)")
print(f"Weighted by attempts: {avg_weighted:.4f}")

tstat, pval = st.ttest_1samp(pivot['diff_8minus7'].to_numpy(), 0.0)
print(f"Paired t-test across distances: t={tstat:.2f}, p={pval:.3f}")

# Sanity peeks
print("\nCounts by play_type (in the 7/8 sample):")
print(dfe['play_type'].value_counts())

print("\nBlocked rate by play_type × hold_depth (in the 7/8 sample):")
print(dfe.groupby(['play_type','hold_depth'])['is_blocked'].mean())

print("\nTop 10 distances by total attempts (N7+N8):")
print(pivot.sort_values('N_total', ascending=False).head(10)[['N_total','diff_8minus7']])

"""# **Do we have missing games in 2021/2024?**"""

if 'df_pbp' not in globals():
    PATH = "/content/drive/MyDrive/NFL Merged Data/merged_nfl_data_1999_2025_TRIM.csv"
    df_pbp = pd.read_csv(PATH, low_memory=False)

df = df_pbp.copy()
df['year'] = pd.to_numeric(df.get('year'), errors='coerce').astype('Int64')
df['week'] = pd.to_numeric(df.get('week'), errors='coerce').astype('Int64')
df = df.dropna(subset=['year','game_id']).copy()

# Normalize season_type
stype = df.get('season_type', pd.Series(index=df.index, dtype=object)).astype(str).str.lower()
stype = (stype.replace({'regular':'reg','postseason':'post','playoffs':'post'}))
df['season_type_norm'] = stype.where(stype.isin(['reg','post']), other='other')

# Expected regular games by era
def expected_regular_games(y: int) -> int:
    if y <= 2001: return 248
    elif y <= 2020: return 256
    else: return 272

gb = (df.groupby(['year','season_type_norm'])['game_id']
        .nunique()
        .unstack(fill_value=0)
        .sort_index())

print("Unique games by year × season_type_norm:\n", gb.tail(15))

obs_reg = gb.get('reg', pd.Series(dtype=int))
audit = pd.DataFrame({'observed_regular': obs_reg}).sort_index()
audit['expected_regular'] = audit.index.astype(int).map(expected_regular_games)
audit['missing_regular']  = audit['expected_regular'] - audit['observed_regular']

print("\nObserved vs expected regular-season game counts (recent years):")
print(audit.loc[audit.index>=2019].fillna(0).astype(int).to_string())

print("\nYears with missing regular-season games:")
print(audit[audit['missing_regular'] > 0].index.tolist())

# 2021/2024 weeks present (regular only)
for yr in [2021, 2024]:
    d = df[(df['year']==yr) & (df['season_type_norm']=='reg')].drop_duplicates(['game_id'])
    if d.empty:
        print(f"\n{yr}: no regular-season games found.")
        continue
    weeks_present = sorted(df[(df['year']==yr) & (df['season_type_norm']=='reg')]['week'].dropna().unique().astype(int).tolist())
    print(f"\n{yr} regular-season weeks present:", weeks_present)
    per_week = (df[(df['year']==yr) & (df['season_type_norm']=='reg')]
                .groupby('week')['game_id'].nunique().sort_index())
    print("Games per week (unique game_id):")
    print(per_week.to_string())

"""# **Misses vs blocks vs “not-made” (distance-matched), pooled + split FG/XP**"""

PATH = "/content/drive/MyDrive/NFL Merged Data/merged_nfl_data_1999_2025_TRIM.csv"
df_pbp = pd.read_csv(PATH, low_memory=False)

keep = df_pbp['play_type'].astype(str).str.lower().isin(['field_goal', 'extra_point'])
df = df_pbp.loc[keep].copy()

fg_out = df.get('field_goal_result', pd.Series(index=df.index, dtype=object)).astype(str).str.lower()
xp_out = df.get('extra_point_result', pd.Series(index=df.index, dtype=object)).astype(str).str.lower()
df['outcome_raw'] = np.where(df['play_type'].astype(str).str.lower().eq('extra_point'), xp_out, fg_out)

valid = {'made','good','missed','failed','blocked','aborted'}
df = df[df['outcome_raw'].isin(valid)].copy()

df['is_made']    = df['outcome_raw'].isin(['made','good']).astype(int)
df['is_blocked'] = df['outcome_raw'].eq('blocked').astype(int)
df['is_missed']  = df['outcome_raw'].isin(['missed','failed']).astype(int)
df['is_notmade'] = 1 - df['is_made']  # miss OR block OR aborted/failed (already in valid)

df['kick_distance'] = pd.to_numeric(df.get('kick_distance'), errors='coerce')
df['yardline_100']  = pd.to_numeric(df.get('yardline_100'), errors='coerce')
df = df.dropna(subset=['kick_distance','yardline_100']).copy()

df['hold_depth'] = (df['kick_distance'] - df['yardline_100'] - 10).round().astype('Int64')
df = df[df['hold_depth'].isin([7,8])].copy()
df['hold_depth'] = df['hold_depth'].astype(int)

df['dist_key'] = df['kick_distance'].round().astype('Int64')

# distances with both depths
depth_counts = df.groupby(['dist_key','hold_depth']).size().unstack(fill_value=0).reindex(columns=[7,8], fill_value=0)
eligible = depth_counts[(depth_counts[7] > 0) & (depth_counts[8] > 0)].index

dfe = df[df['dist_key'].isin(eligible)].copy()

def within_distance_diff(data, outcome_col):
    cs = (data.groupby(['dist_key','hold_depth'])[outcome_col]
              .agg(rate='mean', N='size')
              .reset_index())
    pv = (cs.pivot(index='dist_key', columns='hold_depth', values=['rate','N'])
            .reindex(columns=pd.MultiIndex.from_product([['rate','N'], [7,8]]))
            .dropna())
    pv['diff_8minus7'] = pv[('rate',8)] - pv[('rate',7)]
    pv['N_total']      = pv[('N',7)] + pv[('N',8)]
    return pv

def summarize(name, pv):
    avg_unw = pv['diff_8minus7'].mean()
    avg_w   = (pv['diff_8minus7'] * pv['N_total']).sum() / pv['N_total'].sum()
    tstat, pval = st.ttest_1samp(pv['diff_8minus7'].to_numpy(), 0.0)
    print(f"\n=== {name} (distance-matched; pooled FG+XP) ===")
    print(f"Matched distances: {len(pv):,}")
    print(f"Mean diff (8 − 7): {avg_unw:.4f} | weighted: {avg_w:.4f} | t={tstat:.2f}, p={pval:.3f}")

pv_notmade = within_distance_diff(dfe, 'is_notmade')
pv_block   = within_distance_diff(dfe, 'is_blocked')
pv_miss    = within_distance_diff(dfe, 'is_missed')

summarize("NOT-MADE rate (miss/block/failed/aborted)", pv_notmade)
summarize("BLOCKED rate", pv_block)
summarize("MISSED rate (miss/failed)", pv_miss)

# Split FG vs XP
for pt in ['field_goal','extra_point']:
    sub = dfe[dfe['play_type'].astype(str).str.lower().eq(pt)]
    if sub.empty:
        continue
    print(f"\n--- Split: {pt} ---")
    summarize("NOT-MADE", within_distance_diff(sub, 'is_notmade'))
    summarize("BLOCKED",  within_distance_diff(sub, 'is_blocked'))
    summarize("MISSED",   within_distance_diff(sub, 'is_missed'))

if 'df_pbp' not in globals():
    PATH = "/content/drive/MyDrive/NFL Merged Data/merged_nfl_data_1999_2025_TRIM.csv"
    df_pbp = pd.read_csv(PATH, low_memory=False)


# 1) Unified kicks frame (FG + XP)

keep = df_pbp['play_type'].astype(str).str.lower().isin(['field_goal', 'extra_point'])
df = df_pbp.loc[keep].copy()

fg_out = df.get('field_goal_result', pd.Series(index=df.index, dtype=object)).astype(str).str.lower()
xp_out = df.get('extra_point_result', pd.Series(index=df.index, dtype=object)).astype(str).str.lower()

df['outcome_raw'] = np.where(
    df['play_type'].astype(str).str.lower().eq('extra_point'),
    xp_out,
    fg_out
)

valid = {'made','missed','blocked','good','failed','aborted'}
df = df[df['outcome_raw'].isin(valid)].copy()

# Blocked flag (only explicit "blocked")
df['is_blocked'] = df['outcome_raw'].eq('blocked').astype(int)

# Numeric distance + season
df['kick_distance'] = pd.to_numeric(df.get('kick_distance'), errors='coerce')
df['year'] = pd.to_numeric(df.get('year'), errors='coerce').astype('Int64')
df = df.dropna(subset=['kick_distance','year']).copy()
df['dist_int'] = df['kick_distance'].round().astype('Int64')


# 2) OVERALL seasonal block rate (FG + XP mixed)

season_overall = (df.groupby('year')['is_blocked']
                    .agg(block_rate='mean', attempts='size')
                    .reset_index()
                    .sort_values('year'))
print("=== Overall block rate by season (FG + XP) ===")
print(season_overall.to_string(index=False))


# 3) DISTANCE-STANDARDIZED seasonal block rate (controls attempt mix)
#    Baseline mix = 2015–2019 over exact distances

baseline_mask = df['year'].between(2015, 2019)
base_dist_counts = (df.loc[baseline_mask]
                      .groupby('dist_int')
                      .size()
                      .rename('n_base'))

if base_dist_counts.sum() == 0:
    raise RuntimeError("Baseline window 2015–2019 has zero kicks. Choose a different baseline window.")

base_weights = (base_dist_counts / base_dist_counts.sum()).dropna()

by_season_dist = (df.groupby(['year','dist_int'])['is_blocked']
                    .mean()
                    .rename('rate_sd')
                    .reset_index())

std_rows = []
for yr, g in by_season_dist.groupby('year'):
    merged = g.merge(base_weights.rename('w'), left_on='dist_int', right_index=True, how='inner')
    if merged.empty:
        continue
    std_rate = (merged['rate_sd'] * merged['w']).sum() / merged['w'].sum()
    std_rows.append({'year': int(yr), 'block_rate_std': std_rate, 'dist_cells_used': int(len(merged))})

season_std = pd.DataFrame(std_rows).sort_values('year')
print("\n=== Distance-standardized block rate by season (baseline mix = 2015–2019) ===")
print(season_std.to_string(index=False))


# 4) Same standardization but split by play type

def std_by_type(pt: str):
    dft = df[df['play_type'].astype(str).str.lower().eq(pt)].copy()
    tmp = (dft.groupby(['year','dist_int'])['is_blocked']
             .mean()
             .rename('rate_sd')
             .reset_index())
    rows = []
    for yr, g in tmp.groupby('year'):
        merged = g.merge(base_weights.rename('w'), left_on='dist_int', right_index=True, how='inner')
        if merged.empty:
            continue
        std_rate = (merged['rate_sd'] * merged['w']).sum() / merged['w'].sum()
        rows.append({'year': int(yr), f'{pt}_block_rate_std': std_rate})
    return pd.DataFrame(rows).sort_values('year')

std_fg  = std_by_type('field_goal')
std_xp  = std_by_type('extra_point')

season_std_split = (season_std
                    .merge(std_fg, on='year', how='left')
                    .merge(std_xp, on='year', how='left'))

print("\n=== Distance-standardized (split FG vs XP), same baseline ===")
print(season_std_split.to_string(index=False))


# 5) Trend tests: are blocks declining? (overall and standardized)

def slope_test(df_rate, col):
    d = df_rate.dropna(subset=['year', col]).copy()
    X = sm.add_constant(d['year'].astype(int))
    y = d[col].astype(float)
    res = sm.OLS(y, X).fit()
    b = res.params['year']
    se = res.bse['year']
    print(f"\nTrend for {col}: slope per year = {b:.6f} (SE {se:.6f}), t={res.tvalues['year']:.2f}, p={res.pvalues['year']:.4f}")
    return res

_ = slope_test(season_overall, 'block_rate')
if not season_std.empty:
    _ = slope_test(season_std, 'block_rate_std')


# 6) by hold depth (7 vs 8) over seasons

if 'yardline_100' in df_pbp.columns:
    df_hd = df_pbp.loc[keep].copy()

    fg2 = df_hd.get('field_goal_result', pd.Series(index=df_hd.index, dtype=object)).astype(str).str.lower()
    xp2 = df_hd.get('extra_point_result', pd.Series(index=df_hd.index, dtype=object)).astype(str).str.lower()
    df_hd['outcome_raw'] = np.where(df_hd['play_type'].astype(str).str.lower().eq('extra_point'), xp2, fg2)
    df_hd = df_hd[df_hd['outcome_raw'].isin(valid)].copy()
    df_hd['is_blocked'] = df_hd['outcome_raw'].eq('blocked').astype(int)

    df_hd['kick_distance'] = pd.to_numeric(df_hd.get('kick_distance'), errors='coerce')
    df_hd['yardline_100']  = pd.to_numeric(df_hd.get('yardline_100'), errors='coerce')
    df_hd['year']          = pd.to_numeric(df_hd.get('year'), errors='coerce').astype('Int64')
    df_hd = df_hd.dropna(subset=['kick_distance','yardline_100','year']).copy()

    df_hd['hold_depth'] = (df_hd['kick_distance'] - df_hd['yardline_100'] - 10).round().astype('Int64')
    df_hd = df_hd[df_hd['hold_depth'].isin([7,8])].copy()
    df_hd['hold_depth'] = df_hd['hold_depth'].astype(int)

    by_season_hold = (df_hd.groupby(['year','hold_depth'])['is_blocked']
                        .agg(block_rate='mean', attempts='size')
                        .reset_index()
                        .sort_values(['year','hold_depth']))

    print("\n=== Seasonal block rates by hold depth (7 vs 8) ===")
    print(by_season_hold.to_string(index=False))
    