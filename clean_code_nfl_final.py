# -*- coding: utf-8 -*-
"""Clean Code NFL Final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FMQW7uZSJqnYdYezZIcYjvfYTDLxFxM3
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import statsmodels.api as sm
import statsmodels.formula.api as smf
import patsy
from patsy import dmatrix
from scipy.stats import gaussian_kde, norm
from scipy.stats import norm

path_merged = "/content/drive/MyDrive/NFL Merged Data/merged_nfl_data_1999_2025_TRIM.csv"
df_pbp = pd.read_csv(path_merged)

unique_years = df_pbp["year"].unique()
print("Unique years in the dataset:", unique_years)

year_counts = df_pbp["year"].value_counts().sort_index()
print(year_counts)

# Keep true field goals, not extra points
df_field_goal = df_pbp[
    (df_pbp['play_type'] == 'field_goal')
    & df_pbp['field_goal_result'].isin(['made','missed','blocked'])
].copy()

# map to 0/1
df_field_goal['field_goal_result'] = (
    df_field_goal['field_goal_result']
      .map({'made':1,'missed':0,'blocked':0})
      .astype(int)
)

df_field_goal = df_pbp[df_pbp['field_goal_result'].isin(['made', 'missed', 'blocked'])].copy()
df_field_goal['field_goal_result'] = df_field_goal['field_goal_result'].map({'made': 1, 'missed': 0, 'blocked': 0}).astype(int)

print(df_field_goal.columns)
print(df_field_goal['yardline_100'].describe())
print(df_field_goal['kick_distance'].describe())

"""# **Summary**"""

# 1) Overall summary
print("=== Overall summary ===")
print(df_field_goal[['kick_distance','field_goal_result']].describe().T)

# 2) Summary by yard-line
by_dist = df_field_goal.groupby('kick_distance')['field_goal_result'] \
                      .agg(count='size', mean='mean') \
                      .reset_index()
print("\n=== Summary by yardline ===")
print(by_dist)

# 3) Summary by season
by_season = df_field_goal.groupby('year').agg(
    yardline_mean=('kick_distance', 'mean'),
    attempts=('field_goal_result', 'size'),
    success_rate=('field_goal_result', 'mean')
)
print("\n=== Summary by season ===")
print(by_season)

# 4) Plot: success rate vs. yard-line
plt.figure()
plt.plot(by_dist['kick_distance'], by_dist['mean'])
plt.xlabel('Scrimmage Yardline')
plt.ylabel('Success Rate')
plt.title('Field-Goal Success Rate by Yardline')
plt.tight_layout()
plt.show()

# 5) Plot: mean attempted yard-line by season
plt.figure()
plt.plot(by_season.index, by_season['yardline_mean'])
plt.xlabel('Season')
plt.ylabel('Mean Attempted Yardline')
plt.title('Mean Attempted Yardline by Season')
plt.tight_layout()
plt.show()

# 6) Plot: mean success rate by season
plt.figure()
plt.plot(by_season.index, by_season['success_rate'])
plt.xlabel('Season')
plt.ylabel('Mean Success Rate')
plt.title('Mean Field-Goal Success Rate by Season')
plt.tight_layout()
plt.show()

"""# **ROOKIES ONLY (SUMMARY)**"""

df_field_goal = df_field_goal.copy()

# Career attempts per kicker
df_field_goal['career_attempts'] = (
    df_field_goal
    .groupby('kicker_player_name', observed=True)['kicker_player_name']
    .transform('size')
)

kickers = (
    df_field_goal[['kicker_player_name', 'career_attempts']]
    .drop_duplicates()
    .sort_values(['career_attempts', 'kicker_player_name'])  # stable tie-break
    .reset_index(drop=True)
)

# cum share of total attempts
kickers['cum_share'] = kickers['career_attempts'].cumsum() / kickers['career_attempts'].sum()

# attempt-share terciles (≈ 1/3 attempts each)
kickers['quality'] = pd.cut(
    kickers['cum_share'],
    bins=[0.0, 1/3, 2/3, 1.0],
    labels=['Rookie', 'Mid', 'Veteran'],
    include_lowest=True,
    right=True
).astype('category')

df_field_goal['quality'] = df_field_goal['kicker_player_name'].map(
    kickers.set_index('kicker_player_name')['quality']
).astype('category')

print(df_field_goal['quality'].value_counts())

# Rookie slice
df_r = df_field_goal.loc[df_field_goal['quality'].eq('Rookie')].copy()
df_r['field_goal_result'] = pd.to_numeric(df_r['field_goal_result'], errors='coerce')
df_r['kick_distance'] = pd.to_numeric(df_r['kick_distance'], errors='coerce')
df_r = df_r.dropna(subset=['field_goal_result', 'kick_distance'])


# Season column (prefer 'season', else use 'year')
if 'season' not in df_r.columns and 'year' in df_r.columns:
    df_r['season'] = df_r['year']

# Ensure numeric
df_r['season'] = pd.to_numeric(df_r['season'], errors='coerce')
df_r['kick_distance'] = pd.to_numeric(df_r['kick_distance'], errors='coerce')
df_r['field_goal_result'] = pd.to_numeric(df_r['field_goal_result'], errors='coerce')

# Drop rows missing essentials
df_r = df_r.dropna(subset=['kick_distance', 'field_goal_result', 'season']).copy()

# For distance summaries, use rounded yards and keep 20..65 only
df_r['dist_yd'] = df_r['kick_distance'].round().astype(int)
df_r_inrange = df_r[(df_r['dist_yd'] >= 20) & (df_r['dist_yd'] <= 50)].copy()

# 1) Overall summary
print("=== Rookie-only overall summary ===")
print(df_r[['kick_distance', 'field_goal_result']].describe().T)

# 2) Summary by distance (20–50)
by_dist = (
    df_r_inrange
      .groupby('dist_yd', as_index=False)['field_goal_result']
      .agg(count='size', mean='mean')
      .rename(columns={'dist_yd': 'kick_distance'})
      .sort_values('kick_distance')
)
print("\n=== Rookie-only summary by distance (20–50 yds) ===")
print(by_dist)

# 3) Summary by season
by_season = (
    df_r
      .groupby('season')
      .agg(
          distance_mean=('kick_distance', 'mean'),
          attempts=('field_goal_result', 'size'),
          success_rate=('field_goal_result', 'mean')
      )
      .sort_index()
)
print("\n=== Rookie-only summary by season ===")
print(by_season)

# 4) Plot: success rate vs. distance (20–65)
min_attempts = 10
plot_df = by_dist[by_dist['count'] >= min_attempts]
plt.figure()
plt.plot(plot_df['kick_distance'], plot_df['mean'])
plt.xlabel('Kick distance (yards)')
plt.ylabel('Success rate')
plt.title('Rookie FG success rate by distance (20–50 yds)')
plt.tight_layout()
plt.show()

# 5) Plot: mean attempted distance by season
plt.figure()
plt.plot(by_season.index, by_season['distance_mean'])
plt.xlabel('Season')
plt.ylabel('Mean kick distance (yds)')
plt.title('Rookie mean attempted distance by season')
plt.tight_layout()
plt.show()

# 6) Plot: mean success rate by season
plt.figure()
plt.plot(by_season.index, by_season['success_rate'])
plt.xlabel('Season')
plt.ylabel('Success rate')
plt.title('Rookie field-goal success rate by season')
plt.tight_layout()
plt.show()

"""# SUCCESS PROBABILITY BY **DISTANCE**"""

# Round distance to nearest yard
df_field_goal["dist_yd"] = df_field_goal["kick_distance"].round().astype(int)

# Aggregate success by exact distance
by_dist = (
    df_field_goal.groupby("dist_yd")["field_goal_result"]
      .agg(success_rate="mean", attempts="size")
      .reset_index()
      .sort_values("dist_yd")
)

# Filter sparse distances to reduce noise
min_attempts = 20
plot_df = by_dist[by_dist["attempts"] >= min_attempts].copy()

# Plot
plt.figure()
plt.plot(plot_df["dist_yd"], plot_df["success_rate"])
plt.xlabel("Kick distance in yards")
plt.ylabel("Probability of success")
plt.title("Field goal success probability by distance")
plt.tight_layout()

out_path = "/content/drive/MyDrive/NFL Merged Data/fg_success_by_distance.png"
plt.savefig(out_path, dpi=150)

print(plot_df.head(10))
print("Saved to:", out_path)

"""## Only **Rookies** - SUCCESS PROBABILITY BY **DISTANCE**"""

# Rookie slice
df_r = df_field_goal.loc[df_field_goal['quality'].eq('Rookie')].copy()
df_r['field_goal_result'] = pd.to_numeric(df_r['field_goal_result'], errors='coerce')
df_r['kick_distance'] = pd.to_numeric(df_r['kick_distance'], errors='coerce')
df_r = df_r.dropna(subset=['field_goal_result', 'kick_distance'])

# Round exact yard and keep only 20..50 yards
df_r['dist_yd'] = df_r['kick_distance'].round().astype(int)
df_r = df_r[(df_r['dist_yd'] >= 20) & (df_r['dist_yd'] <= 50)]

# Aggregate success by distance
by_dist = (
    df_r.groupby('dist_yd')['field_goal_result']
        .agg(success_rate='mean', attempts='size')
        .reset_index()
        .sort_values('dist_yd')
)

# Filter sparse bins to reduce noise
min_attempts = 10
plot_df = by_dist[by_dist['attempts'] >= min_attempts]

# Plot
plt.figure()
plt.plot(plot_df['dist_yd'], plot_df['success_rate'])
plt.xlim(20, 50)
plt.xlabel('Kick distance (yards)')
plt.ylabel('Probability of success')
plt.title('Rookie FG success probability by distance (20–50 yds)')
plt.tight_layout()
plt.show()

"""# **DENSITY-JUMP TEST (COUNT-BASED, YL COLUMN)**"""

# STEP 1: rebuild a *yard-line* integer column called “yl”

df_field_goal = df_field_goal.drop(columns=['yl'], errors='ignore')

df_field_goal['yl'] = (
    pd.to_numeric(df_field_goal['kick_distance'], errors='coerce')
      .round(0)
      .astype('Int64')
)

# keep only plausible scrimmage positions (0–48 yd in from the EZ)
df_jump = df_field_goal.copy()
print("dtype of df_field_goal['yl']:", df_field_goal['yl'].dtype)   # Int64 / int64


# STEP 2: pre-compute counts_by_yl  (yl → # FG attempts)

counts_by_yl = df_field_goal['yl'].value_counts().sort_index()
# e.g. counts_by_yl.loc[33] = how many attempts snapped from the 33-yd line


# STEP 3 ▸ count-based McCrary density-jump test, now on “yl”

def density_jump_test_counts(counts_series, cutpoint, bandwidth=10):
    """
    McCrary-style density jump around a scrimmage yard-line `cutpoint`,
    using integer counts already tabulated in `counts_series`.
    """
    # 1 build a tiny table with distances in [cut-B, cut+B]
    lower, upper = cutpoint - bandwidth, cutpoint + bandwidth
    dists = np.arange(lower, upper + 1)        # inclusive integers
    df_cnt = pd.DataFrame({'yl': dists})
    df_cnt['count'] = df_cnt['yl'].map(counts_series).fillna(0).astype(int)

    # 2 running variable
    df_cnt['rp'] = df_cnt['yl'] - cutpoint

    # 3 split left / right of the cut
    left, right = df_cnt[df_cnt['yl'] < cutpoint], df_cnt[df_cnt['yl'] >= cutpoint]

    # 4 simple OLS (count ~ 1 + rp) on each side
    Xl, Xr = sm.add_constant(left['rp']), sm.add_constant(right['rp'])
    ml, mr = sm.OLS(left['count'], Xl).fit(), sm.OLS(right['count'], Xr).fit()

    dens_left,  dens_right = float(ml.params['const']), float(mr.params['const'])
    jump  = dens_right - dens_left
    se    = np.sqrt(ml.cov_params().loc['const', 'const'] +
                    mr.cov_params().loc['const', 'const'])
    z_val = jump / se
    p_val = 2 * (1 - norm.cdf(abs(z_val)))

    return {
        'cut': cutpoint,
        'dens_left': dens_left, 'dens_right': dens_right,
        'jump': jump, 'se_jump': float(se),
        'z': float(z_val), 'p_value': float(p_val)
    }


# STEP 4: test for the yard-lines

candidate_cuts = [20, 25, 30, 31, 32, 33, 34, 35,
                  36, 37, 38, 39, 40, 41, 45]

results = [density_jump_test_counts(counts_by_yl, c, bandwidth=10)
           for c in candidate_cuts]

df_density_jumps = pd.DataFrame(results)[
    ['cut', 'dens_left', 'dens_right', 'jump', 'se_jump', 'z', 'p_value']
]

print("---- Density-jump results (count-based, yard-line version) ----")
print(df_density_jumps.to_string(index=False))

"""# **RAW SUCCESS RATE SCATTER + LOWESS**"""

# Raw success rate and attempt counts by distance
success_by_dist = df_field_goal.groupby('kick_distance')['field_goal_result'].mean().reset_index(name='success_rate')
attempts_by_dist = df_field_goal['kick_distance'].value_counts().sort_index()
success_by_dist['attempts'] = success_by_dist['kick_distance'].map(attempts_by_dist)

# 2 Scatter‐plot with point size ∝ attempts, plus a LOWESS curve
plt.figure(figsize=(10,4))
plt.scatter(success_by_dist['kick_distance'], success_by_dist['success_rate'],
            s=success_by_dist['attempts'] * 0.05,
            alpha=0.6, label="Raw success rate (size ∝ # attempts)")

lowess = sm.nonparametric.lowess(success_by_dist['success_rate'],
                                 success_by_dist['kick_distance'],
                                 frac=0.3)
plt.plot(lowess[:,0], lowess[:,1], color='red', lw=2, label="LOWESS smoother")

plt.axvline(33, color='purple', linestyle='--', alpha=0.6, label="33 yd")
plt.xlabel("Field‐Goal Distance (yards)")
plt.ylabel("Success Probability")
plt.title("Raw FG Success Rate vs. Distance")
plt.legend()
plt.tight_layout()
plt.show()

"""# **RDD LOOP (LPM + LOGIT)**"""

for c in [30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 45]:
    # 1) Treatment & running‐variable
    df_field_goal[f'above{c}'] = (df_field_goal['kick_distance'] >= c).astype(int)
    df_field_goal[f'run{c}']   = df_field_goal['kick_distance'] - c

    # 2) Subset to ±10 yd around the cut
    lo, hi = c-10, c+10
    df_rdd = df_field_goal[
        (df_field_goal['kick_distance'] >= lo) &
        (df_field_goal['kick_distance'] <= hi)
    ].copy()

    # 3) Linear Probability Model (LPM)
    model_lpm = sm.OLS(
        df_rdd['field_goal_result'],
        sm.add_constant(df_rdd[[f'above{c}', f'run{c}']])
    ).fit(cov_type='HC1')
    print(f"RDD (LPM) at {c} yd – Coef on above{c}:")
    print(model_lpm.summary().tables[1], "\n")

    # 4) Logistic RDD
    model_logit = sm.Logit(
        df_rdd['field_goal_result'],
        sm.add_constant(df_rdd[[f'above{c}', f'run{c}']])
    ).fit(disp=False)
    print(f"RDD (Logit) at {c} yd – Coef on above{c}:")
    print(model_logit.summary2().tables[1], "\n" + ("-"*60) + "\n")

"""# **KINK** MODELS"""

# Kink at the 37-yd scrimmage line
df_field_goal['yard_minus_37'] = df_field_goal['kick_distance'] - 37
df_field_goal['left_of_37']  = np.where(df_field_goal['kick_distance'] <  37, df_field_goal['yard_minus_37'], 0)
df_field_goal['right_of_37'] = np.where(df_field_goal['kick_distance'] >= 37, df_field_goal['yard_minus_37'], 0)
df_kink_37 = df_field_goal[(df_field_goal['kick_distance'] >= 27) & (df_field_goal['kick_distance'] <= 47)].copy()
kink37 = sm.OLS(df_kink_37['field_goal_result'],
               sm.add_constant(df_kink_37[['left_of_37','right_of_37']])
              ).fit(cov_type='HC1')
print("Kink-model at 37 yd (scrimmage yardline):")
print(kink37.summary().tables[1])

# Kink at the 35-yd scrimmage line
df_field_goal['yard_minus_35'] = df_field_goal['kick_distance'] - 35
df_field_goal['left_of_35']  = np.where(df_field_goal['kick_distance'] <  35, df_field_goal['yard_minus_35'], 0)
df_field_goal['right_of_35'] = np.where(df_field_goal['kick_distance'] >= 35, df_field_goal['yard_minus_35'], 0)
df_kink_35 = df_field_goal[(df_field_goal['kick_distance'] >= 25) & (df_field_goal['kick_distance'] <= 45)].copy()
kink35 = sm.OLS(df_kink_35['field_goal_result'],
               sm.add_constant(df_kink_35[['left_of_35','right_of_35']])
              ).fit(cov_type='HC1')
print("\nKink-model at 35 yd (scrimmage yardline):")
print(kink35.summary().tables[1])

# 0) Numeric stadium dummy once-and-for-all
df_field_goal['stadium_open'] = (df_field_goal['roof'].fillna("unknown") == 'open').astype(int)
df_field_goal['temp_filled']  = df_field_goal['temp'].fillna(df_field_goal['temp'].median())

def run_kink(cut):
    yl_c    = f'yl_centered_{cut}'
    below   = f'below{cut}_slope'
    above   = f'above{cut}_slope'

    # 1) build the hinge variables
    df_field_goal[yl_c]  = df_field_goal['kick_distance'] - cut
    df_field_goal[below] = np.where(df_field_goal['kick_distance'] <  cut,
                                    df_field_goal[yl_c], 0)
    df_field_goal[above] = np.where(df_field_goal['kick_distance'] >= cut,
                                    df_field_goal[yl_c], 0)

    # 2) subset ±10 yards around the cut
    lo, hi = cut-10, cut+10
    df_kink = df_field_goal[
        (df_field_goal['kick_distance'] >= lo) &
        (df_field_goal['kick_distance'] <= hi)
    ].copy()

    # 3) Simple kink (no controls)
    simple = smf.ols(f"field_goal_result ~ {below} + {above}", data=df_kink).fit()
    print(f"Simple Kink{cut} (no controls) slopes:")
    print(f"  Below {cut} slope (β₁) = {simple.params[below]:.4f}")
    print(f"  Above {cut} slope (β₂) = {simple.params[above]:.4f}\n")

    # 4) Controlled kink (clustered by game_id) using stadium_open + temp_filled
    formula = (
        f"field_goal_result ~ {below} + {above}"
        " + stadium_open + temp_filled"
    )
    ctl = smf.ols(formula, data=df_kink).fit(
        cov_type='cluster',
        cov_kwds={'groups': df_kink['game_id']}
    )
    print(f"Kink{cut} with controls (slopes only shown):")
    print(f"  Below {cut} slope (β₁) = {ctl.params[below]:.4f}  "
          f"(p={ctl.pvalues[below]:.3f})")
    print(f"  Above {cut} slope (β₂) = {ctl.params[above]:.4f}  "
          f"(p={ctl.pvalues[above]:.3f})")
    print("\n" + "-"*60 + "\n")

# Run for 33, 34, 36, 38, 39
for cut in [33, 34, 36, 38, 39]:
    run_kink(cut)

"""# **CAETANO DUMMY TESTS (CLUTCH / STADIUM / EXPERIENCE)**"""

# Create 'game_half' column based on 'qtr'
df_field_goal['game_half'] = df_field_goal['qtr'].apply(lambda x: 'First Half' if x <= 2 else ('Second Half' if x <= 4 else 'Overtime'))

# Verify the new column
print(df_field_goal[['qtr', 'game_half']].drop_duplicates())

# Clutch Kicks (Last 2 Minutes or OT)
df_field_goal['clutch_kick'] = ((df_field_goal['game_seconds_remaining'] <= 120) | (df_field_goal['game_half'] == "Overtime")).astype(int)
model_clutch = sm.GLM.from_formula("field_goal_result ~ clutch_kick", family=sm.families.Binomial(), data=df_field_goal)
print(model_clutch.fit().summary())

# Stadium Type (Domed vs Open)

# 0) 0/1 dummy for open vs. domed
df_field_goal['stadium_open'] = (
    df_field_goal['roof']
      .fillna("unknown")
      .eq('open')
).astype(int)

# 1) Binomial GLM on that numeric dummy
import statsmodels.api as sm
model_stadium = sm.GLM.from_formula(
    "field_goal_result ~ stadium_open",
    family=sm.families.Binomial(),
    data=df_field_goal
)
print(model_stadium.fit().summary())

# Kicker Experience
df_field_goal['kicker_experience'] = df_field_goal.groupby('kicker_player_name').cumcount() + 1
model_experience = sm.GLM.from_formula("field_goal_result ~ kicker_experience", family=sm.families.Binomial(), data=df_field_goal)
print(model_experience.fit().summary())

# 0) Numeric stadium dummy
df_field_goal['stadium_open'] = (
    df_field_goal['roof'].fillna("unknown") == 'open'
).astype(int)

# 1) 'stadium_type' and 'clutch_kick'
df_field_goal['stadium_type'] = df_field_goal['roof'].apply(
    lambda x: 'domed' if x in ['dome', 'closed'] else 'open'
)

df_field_goal['clutch_kick'] = (
    (df_field_goal['game_seconds_remaining'] <= 120)
    | (df_field_goal['game_half'] == "Overtime")
).astype(int)

# 2) Wind/temp for domed stadiums:
#    - For wind: 0 (no wind inside a dome)
#    - For temp: 70°F (typical controlled temperature)
df_field_goal['wind_filled'] = df_field_goal['wind']
df_field_goal['temp_filled'] = df_field_goal['temp']

df_field_goal.loc[
    df_field_goal['stadium_type'] == 'domed',
    'wind_filled'
] = 0.0

df_field_goal.loc[
    df_field_goal['stadium_type'] == 'domed',
    'temp_filled'
] = 72.0

# 3) open‐air rows still have missing wind/temp, fill with the overall median:
df_field_goal['wind_filled'] = df_field_goal['wind_filled'].fillna(
    df_field_goal['wind_filled'].median()
)
df_field_goal['temp_filled'] = df_field_goal['temp_filled'].fillna(
    df_field_goal['temp_filled'].median()
)

# 4) Domed rows have no missing wind_filled/temp_filled:
print(
    "Domed wind/temp missing after fill:",
    df_field_goal.loc[df_field_goal['stadium_type']=='domed',
                      ['wind_filled','temp_filled']].isna().sum()
)

# 5) Patsy design matrices *without* C(...)
import patsy, statsmodels.api as sm

formula = (
    "field_goal_result ~ stadium_open"
  + " + kicker_experience + clutch_kick + wind_filled"
  + " + wind_filled + temp_filled"
)

y_all, X_all = patsy.dmatrices(formula,
                               data=df_field_goal,
                               return_type='dataframe')

# 5a) Confirm both stadium types survived:
print(
    "Remaining stadium types in design:",
    df_field_goal.loc[y_all.index, 'stadium_type'].value_counts()
)

# 6) Matching game_id for clustering:
aligned_game_ids = df_field_goal.loc[y_all.index, 'game_id']

# 7)  Clustered logit for correct SEs by game:
model_stadium_fixed = sm.Logit(y_all, X_all).fit(
    cov_type='cluster',
    cov_kwds={'groups': aligned_game_ids}
)

print(model_stadium_fixed.summary())

"""# **Covariate Discontinuity Test**"""

df_field_goal['stadium_type'] = df_field_goal['roof'] \
    .fillna("unknown") \
    .map(lambda x: 'open' if x == 'open' else 'domed')

# Tests on yardline_100

df = df_field_goal.copy()
df['stadium_domed'] = (df['stadium_type'] == 'domed').astype(int)

covariates = ['kicker_experience', 'wind_filled', 'temp_filled', 'stadium_domed', 'clutch_kick']
cuts       = [20, 25, 30, 31, 33, 34, 35, 37, 38]


# 1) Covariate-discontinuity tests at each yardline

disc_results = []
for c in cuts:
    # focus in ±10 yards around each cut
    win = df[(df['kick_distance'] >= c-10) & (df['kick_distance'] <= c+10)].copy()
    win['D']  = (win['kick_distance'] >= c).astype(int)
    win['rp'] = win['kick_distance'] - c

    for z in covariates:
        m = smf.ols(f"{z} ~ rp + D", data=win).fit(cov_type='HC1')
        disc_results.append({
            'cut':        c,
            'covariate':  z,
            'coef_D':     m.params['D'],
            'pval_D':     m.pvalues['D']
        })

df_disc = pd.DataFrame(disc_results)


# 2) Linear Covariate-Density Test (LCDT) at each yardline

lcdt_results = []
for c in cuts:
    # Step 1: fit outcome on covariates at exactly X = c
    s1 = df[df['kick_distance'] == c]
    Z1 = sm.add_constant(s1[covariates])
    mod1 = sm.OLS(s1['field_goal_result'], Z1).fit()

    # Step 2: compute Q = Zβ − Y for all X > c
    s2 = df[df['kick_distance'] > c]
    Z2 = sm.add_constant(s2[covariates])
    Q  = mod1.predict(Z2) - s2['field_goal_result']

    theta = Q.mean()
    se    = Q.std(ddof=1) / np.sqrt(len(Q))
    t_stat = theta / se
    p_val  = 2 * (1 - norm.cdf(abs(t_stat)))

    lcdt_results.append({
        'cut':       c,
        'theta_LCDT': theta,
        'SE':        se,
        't_stat':    t_stat,
        'p_value':   p_val
    })

df_lcdt = pd.DataFrame(lcdt_results)

# Results

print("Covariate Discontinuity Tests")
print(df_disc.to_string(index=False))

print("\nLinear CDT Results")
print(df_lcdt.to_string(index=False))

"""# **Univariate Dummy Test - Dummy + Controls - Interactions**"""

spline = "bs(kick_distance, knots=[37], degree=3)"
formula = "field_goal_result ~ " + spline + " + D37 + controls…"


# 1) Stadium_type categorical
df_field_goal['stadium_type'] = (
    df_field_goal['stadium_type']
      .astype('category')
)

# 2) Controls string
controls = "kick_distance + I(kick_distance**2) + I(kick_distance**3) + wind_filled + temp_filled + stadium_type"

# 3) Three models at each yard-line dummy
def run_univariate_models(df, yardline):
    dummy_var = f"D{yardline}"
    # create the dummy on yardline_100
    df[dummy_var] = (df['kick_distance'] == yardline).astype(int)

    print(f"\n=== Univariate Dummy Test at {yardline} yd ===")
    m1 = smf.ols(f"field_goal_result ~ {dummy_var}", data=df).fit(cov_type='HC1')
    print(m1.summary().tables[1])

    print(f"\n=== Dummy + Controls at {yardline} yd ===")
    m2 = smf.ols(f"field_goal_result ~ {dummy_var} + {controls}", data=df).fit(cov_type='HC1')
    print(m2.summary().tables[1])

    print(f"\n=== Interactions at {yardline} yd ===")
    # Interact the dummy with wind, temp, and yardline_100
    m3 = smf.ols(
        f"field_goal_result ~ {dummy_var} * wind_filled"
        f" + {dummy_var} * temp_filled"
        f" + {dummy_var} * kick_distance"
        " + stadium_type + kicker_experience + clutch_kick",
        data=df
    ).fit(cov_type='HC1')
    print(m3.summary().tables[1])

# 4) Run for the cuts you want
for yd in [20, 25, 30, 31, 32, 33, 34, 35, 36, 37, 38]:
    run_univariate_models(df_field_goal, yd)

# 0) pick yard-line cutpoints
yard_cuts = [20, 25, 30, 31, 32, 33, 34, 35, 36, 37, 38]

# 1) center season‐year for stability
df_field_goal["yr_c"] = df_field_goal["year"] - df_field_goal["year"].mean()

# 2) D{c} and year‐interaction D{c}_yr
for c in yard_cuts:
    df_field_goal[f"D{c}"]     = (df_field_goal["kick_distance"] == c).astype(int)
    df_field_goal[f"D{c}_yr"] = df_field_goal[f"D{c}"] * df_field_goal["yr_c"]

# 3) controls
ctrls = "kick_distance + I(kick_distance**2) + wind_filled + temp_filled + stadium_type"

# 4) pooled formula with each dummy and its interaction
formula = (
    "field_goal_result ~ "
    + " + ".join(f"D{c} + D{c}_yr" for c in yard_cuts)
    + " + " + ctrls
)

# 5) fit and cluster by game
m_int = smf.ols(formula, data=df_field_goal).fit(
    cov_type="cluster",
    cov_kwds={"groups": df_field_goal["game_id"]}
)

# 6) Pooled coefficients (main effect and year‐interaction for each D{c})
print(m_int.summary().tables[1])

"""# **Pre and Post 2015**"""

# 0) Yard‐line cutpoints and controls
yard_cuts = [20, 25, 30, 31, 32, 33, 34, 35, 36, 37, 38]
ctrls = (
    "I(kick_distance) + I(kick_distance**2) + wind_filled + temp_filled "
    "+ stadium_type + clutch_kick"
)

# 1) D{c} dummy built off yardline_100
for c in yard_cuts:
    df_field_goal[f"D{c}"] = (df_field_goal["kick_distance"] == c).astype(int)

# 2) Formula string
dummy_terms = " + ".join(f"D{c}" for c in yard_cuts)
formula = f"field_goal_result ~ {dummy_terms} + {ctrls}"

# 3) pre/post 2015 samples
df_pre  = df_field_goal[df_field_goal.year < 2015].copy()
df_post = df_field_goal[df_field_goal.year >= 2015].copy()

# 4) Fit on pre‐2015
model_pre = smf.ols(formula, data=df_pre).fit(
    cov_type="cluster",
    cov_kwds={"groups": df_pre.game_id}
)

# 5) Fit on post‐2015
model_post = smf.ols(formula, data=df_post).fit(
    cov_type="cluster",
    cov_kwds={"groups": df_post.game_id}
)

# 6) tables
print("=== Pre-2015 Model Summary ===")
print(model_pre.summary().tables[1])

print("\n=== Post-2015 Model Summary ===")
print(model_post.summary().tables[1])

try:
    masks
except NameError:
    masks = {}

# Career attempts per row
df_field_goal['career_attempts'] = (
    df_field_goal
    .groupby('kicker_player_name', observed=True)['kicker_player_name']
    .transform('size')
)

# One row per kicker
kickers = (df_field_goal[['kicker_player_name','career_attempts']]
           .drop_duplicates()
           .sort_values('career_attempts'))

# Cumulative share of total attempts across kickers (smallest -> largest)
kickers['cum_attempts'] = kickers['career_attempts'].cumsum()
total_attempts = kickers['career_attempts'].sum()
kickers['cum_share'] = kickers['cum_attempts'] / total_attempts

# Assign tiers so each tier ≈ 1/3 of all attempts
def tier_from_cumshare(s):
    if s <= 1/3:
        return 'Rookie'
    elif s <= 2/3:
        return 'Mid'
    else:
        return 'Veteran'

kickers['quality'] = kickers['cum_share'].apply(tier_from_cumshare).astype('category')

# Map back to every attempt
tier_map = kickers.set_index('kicker_player_name')['quality']
df_field_goal['quality'] = df_field_goal['kicker_player_name'].map(tier_map).astype('category')

# Refresh masks
for q in ['Rookie','Mid','Veteran']:
    masks[q] = df_field_goal['quality'] == q

# Sanity check
print(df_field_goal['quality'].value_counts())

"""# **OLS: POLYNOMIAL + DISTANCE DUMMIES + CONTROLS (CLUSTERED)**"""

# 1) Distance dummies
for d in [33, 34, 35, 36, 37, 38]:
    df_field_goal[f'D{d}'] = (df_field_goal['kick_distance'] == d).astype(int)

# 2) Polynomial terms + dummies + other controls
poly_terms = "kick_distance + I(kick_distance**2)"
dummies   = " + ".join(f"D{d}" for d in [20,25,30,31,32,33,34,35,36,37,38])
controls  = "wind_filled + temp_filled + C(stadium_type) + clutch_kick + kicker_experience"

formula = f"field_goal_result ~ {poly_terms} + {dummies} + {controls}"

# 3) Fit model with cluster‐robust SE’s by game
model = smf.ols(formula, data=df_field_goal, eval_env=0).fit(
    cov_type='cluster',
    cov_kwds={'groups': df_field_goal['game_id']}
)

print(model.summary())

"""**Only Rookies**"""

# 0) Columns check
required = ['quality', 'kick_distance', 'field_goal_result', 'game_id']
missing = [c for c in required if c not in df_field_goal.columns]
if missing:
    raise KeyError(f"df_field_goal missing required columns: {missing}")

# 1) Slice to rookies
df_rook = df_field_goal.loc[df_field_goal['quality'].astype(str).eq('Rookie')].copy()
if df_rook.empty:
    raise ValueError("No rookie attempts found (quality == 'Rookie').")

# 2) Numeric outcome
df_rook['field_goal_result'] = pd.to_numeric(df_rook['field_goal_result'], errors='coerce')
df_rook = df_rook.dropna(subset=['field_goal_result', 'kick_distance', 'game_id']).copy()

# 3) Controls exist
if 'wind_filled' not in df_rook.columns:
    df_rook['wind_filled'] = pd.to_numeric(df_rook.get('wind'), errors='coerce').fillna(0)

if 'temp_filled' not in df_rook.columns:
    t = pd.to_numeric(df_rook.get('temp'), errors='coerce')
    df_rook['temp_filled'] = t.fillna(t.median())

# stadium_type
if 'stadium_type' not in df_rook.columns:
    if 'roof' in df_rook.columns:
        r = df_rook['roof'].astype(str).str.lower()
        df_rook['stadium_type'] = np.where(r.eq('open'), 'open', 'domed')
    else:
        df_rook['stadium_type'] = 'unknown'

df_rook['stadium_type'] = df_rook['stadium_type'].astype('category')

# clutch_kick
if 'clutch_kick' not in df_rook.columns:
    if ('game_seconds_remaining' in df_rook.columns) and ('qtr' in df_rook.columns):
        gsr = pd.to_numeric(df_rook['game_seconds_remaining'], errors='coerce')
        qtr = pd.to_numeric(df_rook['qtr'], errors='coerce')
        df_rook['clutch_kick'] = ((gsr <= 120) | (qtr >= 5)).fillna(False).astype(int)
    else:
        df_rook['clutch_kick'] = 0

# 4) Distance dummies
candidate_distances = [20, 25, 30, 31, 32, 33, 34, 35, 36, 37, 38]
kd = pd.to_numeric(df_rook['kick_distance'], errors='coerce')
df_rook['kick_distance'] = kd
df_rook = df_rook.dropna(subset=['kick_distance']).copy()

present_distances = [d for d in candidate_distances if (df_rook['kick_distance'].round().eq(d)).any()]

for d in present_distances:
    df_rook[f'D{d}'] = df_rook['kick_distance'].round().eq(d).astype(int)

# 5) Formula: polynomial + distance dummies + controls
poly_terms = "kick_distance + I(kick_distance**2)"
dummies = " + ".join(f"D{d}" for d in present_distances) if present_distances else "0"

controls_list = ["wind_filled", "temp_filled", "C(stadium_type)", "clutch_kick"]
if 'kicker_experience' in df_rook.columns:

    df_rook['kicker_experience'] = pd.to_numeric(df_rook['kicker_experience'], errors='coerce')
    controls_list.append("kicker_experience")

controls = " + ".join(controls_list)
formula = f"field_goal_result ~ {poly_terms} + {dummies} + {controls}"

# 6) OLS with cluster-robust SEs by game_id
model = smf.ols(formula, data=df_rook).fit(
    cov_type='cluster',
    cov_kwds={'groups': df_rook['game_id']}
)

print(f"Rookie attempts: {len(df_rook)} across {df_rook['game_id'].nunique()} games")
print(f"Distance dummies used: {present_distances}")
print(model.summary())

# 0) rookies only
df = df_field_goal.loc[df_field_goal["quality"].astype(str).eq("Rookie")].copy()
if df.empty:
    raise ValueError("No rookie attempts (quality == 'Rookie').")

# 1) basic typing / fill
if "season" not in df.columns and "year" in df.columns:
    df["season"] = pd.to_numeric(df["year"], errors="coerce")
else:
    df["season"] = pd.to_numeric(df.get("season"), errors="coerce")

df["kick_distance"] = pd.to_numeric(df["kick_distance"], errors="coerce")
df["field_goal_result"] = pd.to_numeric(df["field_goal_result"], errors="coerce")

if "wind_filled" not in df.columns:
    df["wind_filled"] = pd.to_numeric(df.get("wind"), errors="coerce").fillna(0)
else:
    df["wind_filled"] = pd.to_numeric(df["wind_filled"], errors="coerce").fillna(0)

if "temp_filled" not in df.columns:
    t = pd.to_numeric(df.get("temp"), errors="coerce")
    df["temp_filled"] = t.fillna(t.median())
else:
    t = pd.to_numeric(df["temp_filled"], errors="coerce")
    df["temp_filled"] = t.fillna(t.median())

if "stadium_type" in df.columns:
    df["stadium_type"] = df["stadium_type"].astype("category")

# clutch fallback (only if missing)
if "clutch_kick" not in df.columns:
    if ("game_seconds_remaining" in df.columns) and ("qtr" in df.columns):
        gsr = pd.to_numeric(df["game_seconds_remaining"], errors="coerce")
        qtr = pd.to_numeric(df["qtr"], errors="coerce")
        df["clutch_kick"] = ((gsr <= 120) | (qtr >= 5)).fillna(False).astype(int)
    else:
        df["clutch_kick"] = 0

# drop rows missing essentials
need = ["field_goal_result", "kick_distance", "season"]
df = df.dropna(subset=need).copy()
if df.empty:
    raise ValueError("No rookie rows left after cleaning essentials.")

# 2) distance dummies + year interactions
yard_cuts_all = [25, 30, 33, 34, 35, 36, 37, 38]
df["yr_c"] = df["season"] - df["season"].mean()

kd_round = df["kick_distance"].round().astype(int)
present_cuts = [c for c in yard_cuts_all if (kd_round == c).any()]

for c in present_cuts:
    df[f"D{c}"] = (kd_round == c).astype(int)
    df[f"D{c}_yr"] = df[f"D{c}"] * df["yr_c"]

df["kick_distance_sq"] = df["kick_distance"] ** 2

# 3) formula
poly = "kick_distance + kick_distance_sq"
dummies = " + ".join([f"D{c}" for c in present_cuts]) if present_cuts else "0"
interacts = " + ".join([f"D{c}_yr" for c in present_cuts]) if present_cuts else "0"

maybe_ctrls = ["wind_filled", "temp_filled", "stadium_type", "clutch_kick", "kicker_experience"]
present_ctrls = [c for c in maybe_ctrls if c in df.columns]

if "stadium_type" in present_ctrls and df["stadium_type"].nunique(dropna=True) <= 1:
    present_ctrls.remove("stadium_type")

ctrls = " + ".join(present_ctrls) if present_ctrls else "1"
formula = f"field_goal_result ~ {poly} + {dummies} + {interacts} + {ctrls}"

# 4) fit (cluster by game if possible)
if "game_id" in df.columns and df["game_id"].notna().any():
    res = smf.ols(formula, data=df).fit(cov_type="cluster", cov_kwds={"groups": df["game_id"]})
else:
    res = smf.ols(formula, data=df).fit(cov_type="HC1")

# 5) output
ng = df["game_id"].nunique() if "game_id" in df.columns else "N/A"
print(f"Rookie attempts: {len(df)} | games: {ng}")
print(f"Distance dummies: {present_cuts}")
print(res.summary())

wanted = [k for k in res.params.index if k.startswith("D")]
print("\nDistance dummy + interaction coefs:")
print(res.params.loc[wanted].to_string())
print("\nStd errors:")
print(res.bse.loc[wanted].to_string())

"""# **SEASON FIXED EFFECTS**"""

# 1) Rename & cast to category
df_field_goal = df_field_goal.rename(columns={'year':'season'})
df_field_goal['season'] = df_field_goal['season'].astype('category')

# 2) “season as a factor” formula without C()
formula_fe = (
    "field_goal_result ~ "
    "yardline_100 + I(yardline_100**2) + "
    + " + ".join(f"D{d}" for d in [20,25,30,31,32,33,34,35,36,37,38])
    + " + wind_filled + temp_filled + stadium_type"
    + " + clutch_kick + kicker_experience"
    + " + season"
)

# 3) Clustered OLS
model_fe = smf.ols(
    formula_fe,
    data=df_field_goal
).fit(
    cov_type='cluster',
    cov_kwds={'groups': df_field_goal['game_id']}
)

print(model_fe.summary().tables[1])

"""Only **Rookies**"""

# 0) rookies only
df = df_field_goal.loc[df_field_goal["quality"].astype(str).eq("Rookie")].copy()
if df.empty:
    raise ValueError("No rookie attempts (quality == 'Rookie').")

# 1) season FE (as category) + core numerics
if "season" not in df.columns and "year" in df.columns:
    df["season"] = pd.to_numeric(df["year"], errors="coerce")
else:
    df["season"] = pd.to_numeric(df.get("season"), errors="coerce")
df["season"] = df["season"].astype("Int64").astype("category")

df["yardline_100"] = pd.to_numeric(df.get("yardline_100"), errors="coerce")
df["field_goal_result"] = pd.to_numeric(df.get("field_goal_result"), errors="coerce")

# filled wind/temp (consistent)
if "wind_filled" not in df.columns:
    df["wind_filled"] = pd.to_numeric(df.get("wind"), errors="coerce").fillna(0)
else:
    df["wind_filled"] = pd.to_numeric(df["wind_filled"], errors="coerce").fillna(0)

if "temp_filled" not in df.columns:
    t = pd.to_numeric(df.get("temp"), errors="coerce")
    df["temp_filled"] = t.fillna(t.median())
else:
    t = pd.to_numeric(df["temp_filled"], errors="coerce")
    df["temp_filled"] = t.fillna(t.median())

if "stadium_type" in df.columns:
    df["stadium_type"] = df["stadium_type"].astype("category")

# clutch fallback (only if missing)
if "clutch_kick" not in df.columns:
    if ("game_seconds_remaining" in df.columns) and ("qtr" in df.columns):
        gsr = pd.to_numeric(df["game_seconds_remaining"], errors="coerce")
        qtr = pd.to_numeric(df["qtr"], errors="coerce")
        df["clutch_kick"] = ((gsr <= 120) | (qtr >= 5)).fillna(False).astype(int)
    else:
        df["clutch_kick"] = 0

# drop rows missing essentials
need = ["field_goal_result", "yardline_100", "season"]
df = df.dropna(subset=need).copy()
if df.empty:
    raise ValueError("No rookie rows left after cleaning essentials.")

# 2) yardline dummies (only those that actually appear for rookies)
candidates = [20, 25, 30, 31, 32, 33, 34, 35, 36, 37, 38]
yl = df["yardline_100"].round().astype(int)
present = [d for d in candidates if (yl == d).any()]

for d in present:
    df[f"D{d}"] = (yl == d).astype(int)

df["yardline_100_sq"] = df["yardline_100"] ** 2

# 3) controls (only if present and non-degenerate)
maybe_ctrls = ["wind_filled", "temp_filled", "stadium_type", "clutch_kick", "kicker_experience"]
present_ctrls = [c for c in maybe_ctrls if c in df.columns]

if "stadium_type" in present_ctrls and df["stadium_type"].nunique(dropna=True) <= 1:
    present_ctrls.remove("stadium_type")

# 4) formula (season FE via C(season) but written as just "season" since it's categorical)
dummies = " + ".join([f"D{d}" for d in present]) if present else "0"
ctrls = " + ".join(present_ctrls) if present_ctrls else "1"
formula = f"field_goal_result ~ yardline_100 + yardline_100_sq + {dummies} + {ctrls} + season"

# 5) fit (cluster by game if possible)
if "game_id" in df.columns and df["game_id"].notna().any():
    res = smf.ols(formula, data=df).fit(cov_type="cluster", cov_kwds={"groups": df["game_id"]})
else:
    res = smf.ols(formula, data=df).fit(cov_type="HC1")

print(f"Rookie attempts: {len(df)} | seasons: {df['season'].nunique()} | dummies: {present}")
print(res.summary().tables[1])

"""# **TIME-VARYING DISTANCE SLOPES**"""

# 0) Season int:
df_field_goal['season'] = df_field_goal['season'].astype(int)

# 1) Centre it
df_field_goal['yr_c'] = df_field_goal['season'] - df_field_goal['season'].mean()

# 2) Controls & dummies
controls = "wind_filled + temp_filled + stadium_type + clutch_kick + kicker_experience"
dummies   = " + ".join(f"D{d}" for d in [20,25,30,31,32,33,34,35,36,37,38])

# 3) Time‐varying‐slope formula
formula_tvs = (
    "field_goal_result ~ "
    "yardline_100 * yr_c "
    "+ I(yardline_100**2) * yr_c "
    f"+ {dummies} + {controls}"
)

import statsmodels.formula.api as smf
model_tvs = smf.ols(formula_tvs, data=df_field_goal).fit(
    cov_type='cluster',
    cov_kwds={'groups': df_field_goal['game_id']}
)

print(model_tvs.summary().tables[1])

"""# **Grouped-season fixed effects**"""

# 0) Numeric season column
if 'season' not in df_field_goal.columns:
    df_field_goal['season'] = df_field_goal['year']

df_field_goal['season'] = pd.to_numeric(df_field_goal['season'], errors='coerce').astype(int)

# 1) Define bins (last edge must be > max season if right=False)
bins   = [1999, 2005, 2010, 2015, 2019, 2026]  # 2026 makes 2019–2025 inclusive
labels = ["1999–2004", "2005–2009", "2010–2014", "2015–2019", "2020–2025"]

df_field_goal['yr_bin'] = pd.cut(
    df_field_goal['season'],
    bins=bins,
    labels=labels,
    right=False,
    include_lowest=True
).astype('category')

# 2) Stadium_type categorical so, can drop C(...)
df_field_goal['stadium_type'] = df_field_goal['stadium_type'].astype('category')

# 3) Kick_distance is numeric
df_field_goal['kick_distance'] = pd.to_numeric(df_field_goal['kick_distance'], errors='coerce')
df_field_goal['dist_yd'] = df_field_goal['kick_distance'].round().astype('Int64')

yard_cuts = [20,25,30,31,32,33,34,35,36,37,38]
for d in yard_cuts:
    col = f"D{d}"
    if col not in df_field_goal.columns:
        df_field_goal[col] = (df_field_goal['dist_yd'] == d).astype(int)

# 4) Formula (match “kick_distance + quadratic + dummies + controls” style)
poly_terms = "kick_distance + I(kick_distance**2)"
dummies    = " + ".join(f"D{d}" for d in yard_cuts)
controls   = "wind_filled + temp_filled + stadium_type + clutch_kick + kicker_experience"

formula_bin = f"field_goal_result ~ {poly_terms} + {dummies} + {controls} + yr_bin"

# 5) Clustered OLS
model_bin = smf.ols(formula_bin, data=df_field_goal).fit(
    cov_type='cluster',
    cov_kwds={'groups': df_field_goal['game_id']}
)

print(model_bin.summary().tables[1])

"""**Only Rookies**"""

# 0) rookies only
df = df_field_goal.loc[df_field_goal["quality"].astype(str).eq("Rookie")].copy()
if df.empty:
    raise ValueError("No rookie attempts (quality == 'Rookie').")

# 1) season -> numeric
if "season" not in df.columns and "year" in df.columns:
    df["season"] = pd.to_numeric(df["year"], errors="coerce")
else:
    df["season"] = pd.to_numeric(df.get("season"), errors="coerce")

# 2) grouped season FE bins (edit edges/labels if you want different eras)
bins   = [1999, 2005, 2010, 2015, 2019, 2026]  # 2026 makes 2020–2025 inclusive (right=False)
labels = ["1999–2004", "2005–2009", "2010–2014", "2015–2019", "2020–2025"]

df["yr_bin"] = pd.cut(
    df["season"],
    bins=bins,
    labels=labels,
    right=False,
    include_lowest=True
).astype("category")

# 3) core numerics (consistent with your earlier cleaning)
df["kick_distance"] = pd.to_numeric(df.get("kick_distance"), errors="coerce")
df["field_goal_result"] = pd.to_numeric(df.get("field_goal_result"), errors="coerce")

if "wind_filled" not in df.columns:
    df["wind_filled"] = pd.to_numeric(df.get("wind"), errors="coerce").fillna(0)
else:
    df["wind_filled"] = pd.to_numeric(df["wind_filled"], errors="coerce").fillna(0)

if "temp_filled" not in df.columns:
    t = pd.to_numeric(df.get("temp"), errors="coerce")
    df["temp_filled"] = t.fillna(t.median())
else:
    t = pd.to_numeric(df["temp_filled"], errors="coerce")
    df["temp_filled"] = t.fillna(t.median())

if "stadium_type" in df.columns:
    df["stadium_type"] = df["stadium_type"].astype("category")

# clutch fallback if missing
if "clutch_kick" not in df.columns:
    if ("game_seconds_remaining" in df.columns) and ("qtr" in df.columns):
        gsr = pd.to_numeric(df["game_seconds_remaining"], errors="coerce")
        qtr = pd.to_numeric(df["qtr"], errors="coerce")
        df["clutch_kick"] = ((gsr <= 120) | (qtr >= 5)).fillna(False).astype(int)
    else:
        df["clutch_kick"] = 0

# 4) drop missing essentials (including yr_bin so FE is defined)
need = ["field_goal_result", "kick_distance", "yr_bin"]
df = df.dropna(subset=need).copy()
if df.empty:
    raise ValueError("No rookie rows left after cleaning essentials / yr_bin.")

# 5) distance dummies (only those that appear for rookies)
candidate_distances = [20, 25, 30, 31, 32, 33, 34, 35, 36, 37, 38]
kd_round = df["kick_distance"].round().astype(int)
present_distances = [d for d in candidate_distances if (kd_round == d).any()]

for d in present_distances:
    df[f"D{d}"] = (kd_round == d).astype(int)

df["kick_distance_sq"] = df["kick_distance"] ** 2

# 6) controls (only if present and non-degenerate)
maybe_ctrls = ["wind_filled", "temp_filled", "stadium_type", "clutch_kick", "kicker_experience"]
present_ctrls = [c for c in maybe_ctrls if c in df.columns]

if "stadium_type" in present_ctrls and df["stadium_type"].nunique(dropna=True) <= 1:
    present_ctrls.remove("stadium_type")

# 7) formula (grouped season FE via yr_bin)
poly = "kick_distance + kick_distance_sq"
dummies = " + ".join([f"D{d}" for d in present_distances]) if present_distances else "0"
ctrls = " + ".join(present_ctrls) if present_ctrls else "1"
formula = f"field_goal_result ~ {poly} + {dummies} + {ctrls} + yr_bin"

# 8) fit (cluster by game_id if possible)
if "game_id" in df.columns and df["game_id"].notna().any():
    res = smf.ols(formula, data=df).fit(cov_type="cluster", cov_kwds={"groups": df["game_id"]})
else:
    res = smf.ols(formula, data=df).fit(cov_type="HC1")

print(f"Rookie attempts: {len(df)} | yr_bin counts:\n{df['yr_bin'].value_counts().sort_index()}")
print(f"Distance dummies used: {present_distances}")
print(res.summary().tables[1])